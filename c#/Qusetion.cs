什么是.NET？什么是CLI？什么是CLR？IL是什么？JIT是什么，它是如何工作的？GC是什么，简述一下GC的工作方式？
类（class）和结构（struct）的区别是什么？它们对性能有影响吗？.NET BCL里有哪些是类（结构），为什么它们不是结构（类）？在自定义类型时，您如何选择是类还是结构？
在.NET程序运行过程中，什么是堆，什么是栈？什么情况下会在堆（栈）上分配数据？它们有性能上的区别吗？“结构”对象可能分配在堆上吗？什么情况下会发生，有什么需要注意的吗？
泛型的作用是什么？它有什么优势？它对性能有影响吗？它在执行时的行为是什么？.NET BCL中有哪些泛型类型？举例说明平时编程中您定义的泛型类型。
异常的作用是什么？.NET BCL中有哪些常见的异常？在代码中您是如何捕获/处理异常的？在“catch (ex)”中，“throw”和“throw ex”有什么区别？您会如何设计异常的结构，什么情况下您会抛出异常？
List<T>和T[]的区别是什么，平时你如何进行选择？Dictionary<TKey, TValue>是做什么的？.NET BCL中还有哪些常用的容器？它们分别是如何实现的（哪种数据结构）？分别是适用于哪些场景？
抽象类和接口有什么区别？使用时有什么需要注意的吗？如何选择是定义一个“完全抽象”的抽象类，还是接口？什么是接口的“显式实现”？为什么说它很重要？
字符串是引用类型类型还是结构类型？它和普通的引用类型相比有什么特别的地方吗？使用字符串时有什么需要注意的地方？为什么说StringBuilder比较高效？在连接多个字符串时，它无论何时都比直接相加更高效吗？
如何高效地进行数组复制？“二维数组”和“数组的数组”有什么区别？在使用双重循环遍历一个二维数组时，如何选择内外层的遍历顺序？
什么是元编程，.NET有哪些元编程的手段和场景？什么是反射？能否举一些反射的常用场景？有人说反射性能较差，您怎么看待这个问题？有什么办法可以提高反射的性能吗？
委托是什么？匿名方法是什么？在C# 3.0中，Lambda表达式是什么？扩展方法是什么？LINQ是什么？您觉得C# 3.0中还有哪些重要的特性，它们带来了什么优势？BCL中哪些类库和这些特性有关？您平时最常用哪些？
工作之外您看哪些技术相关的书、网站、社区、项目等等？您还接触哪些.NET以外的技术，能和.NET或.NET中有针对性的部分做个对比吗？


.net是微软推出的框架.CLI是公共语言接口?,CLR公共语言运行环境,IL运行在.net之上的类似汇编的语言,JIT即时编译用于首次加载时编译为可重复运行的模块,GC垃圾收集,主要是根据索引数判断是否收回,有定时机制.

类有类的生存周期而结构没有,需要更多维护.BCL里有Math?性能考虑,结构需要,struct足够.没有逻辑或者只是提供单纯结构的选择struct.

笼统答之需要new的都在堆上,其余在栈中.函数中声明的对象会在当前栈上分配.有区别,栈能够自动收回.结构对象可以分配在堆上,结构对象过大时就会发生.

泛型用于类型安全的操作.优势是类型安全.没有.不清楚.集合,事件,代理.数据库操作时一般使用泛型.

中断流程,冒泡传递.编译异常,运行时异常,IO异常等.TryCatch捕获.throw不处理,而throw则抛出指定异常.依据逻辑不同声明不同一样.在底层业务无关时抛出,交由上层处理.

一个是泛型列表对象,一个是T类型数组,一般选择泛型列表对象,自有灵活,安全.字典泛型,传入指定TKey类型作为key,TValue作为内容.很多容器.List是双链列表,Dict是Hash.列表是变长的固定类型的集合,Dict是有一个对应关系.

继承和组合的区别.抽象允许有实现,接口没有实现逻辑.....

字符串是引用.有个字符串缓存池.他是不可变对象.SB是可变对象.不是,在链接数量少于一定量级时,还不如他的构造所带来的消耗.

Array.copy.一个是存内容,一个是存引用.先遍历外层.

对程序本身的编程,反射,ASP.net MVC使用.程序解析程序自己.数据库链接获取,IoC.适当的缓存+灵巧的架构,不会产生谈反射变的样子.缓存解决反射性能的好办法.

委托是函数的指针.不给名称的方法就是匿名方法.在C#3.0中Lambda就是简化了的匿名方法.语言集成本地查询.var,拓展方法,他们带来了脚本化的灵活.表达式类.Linq最常用.

博客猿,stackflow,javaeye,EF,Asp.netMVC,Mono.除开.net之外常用python.有一个C#与Python语言本身涵盖的设计模式比较.

感觉老赵还可以添加一些抽象类,接口,泛型叠合的考题.这个在实际工作中很常用,而且问题也多.


public static void Reverse(int[] array, int begin, int end)
{
    while (end > begin)
    {
        int temp = array[begin];
        array[begin] = array[end];
        array[end] = temp;

        begin++;
        end--;
    }
}

